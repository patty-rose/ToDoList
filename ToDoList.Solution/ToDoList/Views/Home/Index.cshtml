@{
  Layout = "_Layout";
} 
@* @{} is a razor code block. This particular code says we are using _Layout.cshtml as the layout file *@

<h1>Welcome to the To Do List!</h1>
<p>@Html.ActionLink("See all categories", "Index", "Categories")</p>
<p>@Html.ActionLink("See all items", "Index", "Items")</p> 
@* The ActionLink() method is called on @Html. It takes two required parameters as well as an optional third parameter.
The first parameter "See all items" is the display text for the link. In other words, a user will see a link that says "See all items".
The second parameter "Index" is the target action in the controller.
The third parameter Items is optional, and it specifies the controller that we want to route to. More specifically, our third parameter is the name of the controller without Controller appended to it. Since we've included this third parameter, this ActionLink will take us to the Index() route method in the ItemsController. Otherwise it would match the view-- since we are in home it woudl take us to home controller*@

@* //html helper -- p1 is link text-- so this is string interpolation--similar to template literal- $ denotes we will use {} for c# to evaluate an expression inside of a string. Here it is titling this link the description of the item ie: "walk the dog"
//p2 is the target action (method name in the controller) "Details"
//p3 passing a different kind of variable as an optional extra argument to ActionLink(). The ActionLink method can take an object containing the data that will be passed as arguments to the Action. SO we create a new one here: The code new { id = item.ItemId } creates an anonymous object with the property id from the Item object. This is how .NET knows which id to use in the Details() action. However, keep in mind that property names of the object we pass in must match parameter names used by the target method. In this case, it will need to match the parameter names in our Details() route method id, like this: Details(int id). *@